### 问题1 ：相对于 #define ,使用 const 对象与 enums 有什么好处？

（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查。

（2）IDE可以对const常量进行调试，但是不能对宏常量进行调试。

（3）const可节省空间，避免不必要的内存分配，提高效率。因为#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。

### 问题2  ：const 关键字的意义?

const意味着 ”只读“ 

一道题：

*const*只是一个修饰符，不管怎么样*a*仍然是一个*int*型的变量

*const int a;*

*int const a;*

*const int \*a;*

*int \* const a;*

*int const \* a const;*

本质：*const*在谁后面谁就不可修改，*const*在最前面则将其后移一位即可，二者等效。这里的”谁“可以指*int*/\*/*a*

前两个的作用是一样，*a*是一个常整型数。第三个意味着*a*是一个指向常整型数的指针（也就是，指向的整型数是不可修改的，但指针可以，此最常见于函数的参数，当你只引用传进来指针所指向的值时应该加上*const*修饰符，程序中修改编译就不通过，可以减少程序的*bug*）。

第四个意思*a*是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着*a*是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。

 

*const* 的重要性：

1) 给读你代码的人传达这个参数的应用目的，增强可读性。
2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。

更具体的作用：

1. 欲阻止一个变量被改变，可以使用*const*关键字。在定义该*const*变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了。
2. 对指针来说，可以指定指针本身为*const*，也可以指定指针所指的数据为*const*，或二者同时指定为*const*
3. 在一个函数声明中，*const*可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值
4. 对于类的成员函数，若指定其为*const*类型，则表明其是一个常函数，不能修改类的成员变量
5. 对于类的成员函数，有时候必须指定其返回值为*const*类型，以使得其返回值不为“左值”



以上内容参考CSDN文章：https://blog.csdn.net/zhoukangli/article/details/8035456

### 问题3  :  对象是否一定要初始化，初始化的意义是什么？

绝大多数情况是的，意义是避免产生未定义值或随机生成的值。

### 问题 4 : 创建一个空类，会包含哪些函数?

一个默认构造函数、一个默认拷贝构造函数、一个默认拷贝赋值操作符和一个默认析构函数。这些函数只有在第一次被调用时，才会别编译器创建。所有这些函数都是inline和public的。

### 问题 5 : 在多态中,析构函数为什么要声明成 virtual?

因为，如果delete一个基类的指针时， 如果它指向的是一个子类的对象，那么析构函数不为虚就会导致无法调用子类析构函数，从而导致资源泄露。

### 问题 6 : 在析构函数中调用一个可能失败的函数，会出现什么问题？应该如何处理? 结合 Demo 分析

在析构函数中调用一个可能失败的函数会导致析构函数也可能失败。这可能会导致程序在结束时出现未知错误，因为析构函数是自动调用的，所以无法给出正确的错误信息。

为了处理这种情况，最好的方法是在析构函数中使用 try/catch 语句来捕获可能出现的错误。例如：

```c++
class MyClass 
{
public:
    ~MyClass() 
    {
        try {
            // 调用可能失败的函数
            maybeFail();
        } catch (...) {
            // 处理错误
        }
    }
};
```

这样，即使在析构函数中调用的函数出现错误，也可以使用 catch 语句来捕获并处理错误。

### 问题 7 : 在构造函数和析构函数调用 virtual 函数会产生什么后果？结合 Demo 分析

在构造函数中调用虚函数会导致指向该对象的指针指向的函数是基类的虚函数，而不是派生类的虚函数。这是因为在构造函数执行期间，派生类的内存尚未被分配，所以无法使用派生类的虚函数。

同样，在析构函数中调用虚函数也会导致同样的问题，因为在析构函数执行期间，派生类的内存已被释放，所以也无法使用派生类的虚函数。

举个例子：

```c++
#include <iostream>

class Base {
public:
  Base() {
    std::cout << "Base constructor" << std::endl;
    virtual_func(); // 这里调用的是 Base 类的虚函数
  }
  virtual ~Base() {
    std::cout << "Base destructor" << std::endl;
    virtual_func(); // 这里调用的是 Base 类的虚函数
  }
  virtual void virtual_func() {
    std::cout << "Base virtual function" << std::endl;
  }
};

class Derived : public Base {
public:
  Derived() {
    std::cout << "Derived constructor" << std::endl;
  }
  ~Derived() {
    std::cout << "Derived destructor" << std::endl;
  }
  void virtual_func() {
    std::cout << "Derived virtual function" << std::endl;
  }
};

int main() {
  Base* b = new Derived();
  delete b;
  return 0;
}
```

输出结果为：

```
Base constructor
Base virtual function
Derived constructor
Derived destructor
Base destructor
Base virtual function
```

从输出结果可以看出，派生类构造和析构时调用的仍然是基类的虚函数而不是派生类的函数。综上，如果在构造函数和析构函数调用 virtual 函数，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。

### 问题 8 : 基于对象管理内存资源有什么好处？一般有哪些对象可以管理内存资源?

基于对象管理内存资源的好处之一是它允许自动内存管理。 这意味着程序员不必手动分配和释放内存资源，因为对象会在超出范围或不再需要时自动处理。 这有助于防止内存泄漏并使代码更易于编写和维护。

在面向对象的编程语言中，对象可以管理内存资源。 具体来说，对象可以通过使用构造函数和析构函数来管理内存资源。 构造函数是创建对象时调用的一种特殊方法，可用于为对象分配内存资源。 析构函数是对象被销毁时调用的一种特殊方法，可用于为对象释放内存资源。

### 问题 9 : 管理内存资源的对象可以进行拷贝吗?  比较好的拷贝逻辑应该是什么样子?

可以，管理内存资源的对象（如指针等）的拷贝分为浅拷贝和深拷贝。

如果需要创建管理内存资源的对象的副本，通常最好创建一个新对象并将资源从原始对象显式拷贝到副本。 例如，可以实现一个将原始对象作为参数并将内存资源从原始对象转移到副本的拷贝构造函数。 这可确保副本和原始对象不会同时尝试管理可能导致冲突的同一资源。

### 问题 10 : 开发一个 "容易被正确使用，不容易被误用"接口，首先需要考虑什么? 结合具体 Demo 分析

首先必须考虑客户可能做出什么错误。要尽量使接口直观，易于理解和使用；要明确标注功能；还可以使用约束和默认值：使用约束来限制用户可用的选项，并使用最有可能正确的默认设置；提供明确的反馈：让用户知道操作是否成功或是否发生错误，并就如何解决任何错误提供明确的指导；考虑用户的上下文：在设计界面时考虑用户的环境、目标和需求；与真实用户一起测试界面：进行用户测试以确定界面中的任何问题或需要改进的地方。

假设你为一个用来表现日期的class设计构造函数：

```cpp
class Date {
	public:
		Date(int month, int day, int year);
		...
};
```

乍一看，这个接口通情达理，但是它的客户很容易犯下至少两个错误。

- 一、也许会以错误的次序传递参数

```cpp
Date d(30, 3, 1995); // 应该是 3, 30
1
```

- 二、可能传递一个无效的月份或天数

```cpp
Date d(2, 30, 1995); // 应该是3, 30
```

导入简单的外覆类型来区别天数、月份和年份，然后在Date构造函数中使用这些类型。还可以限制其取值。

### 问题 11 : “促进正确使用”的办法包括哪些？

接口的一致性

与内置类型的行为兼容

### 问题 12 :   传引用比传值的好处在于哪些 ？

在按值传递中，将参数值的副本传递给函数。 这意味着对函数内参数所做的任何更改都不会影响函数外参数的原始值。 这在内存使用方面可以更有效，因为只需要存储一个值的副本。

另一方面，在按引用传递中，对参数内存位置的引用被传递给函数。 这意味着对函数内参数所做的任何更改都会反映在函数外参数的原始值中。 这在时间上更有效，因为它允许函数直接修改原始值，而不必复制它。

当参数是一个较大的对象（如数组或结构体）时，按引用传递也很有用，因为它允许函数直接修改对象，而不必复制它。

总的来说，值传递和引用传递之间的选择取决于程序的具体要求以及内存使用和效率之间的权衡。


### 问题 13 ： 能否返回一个局部变量的指针或者引用？为什么？

不能，因为当局部变量所在的函数结束运行时，这个局部变量就被销毁了，内存被释放。如果返回了一个指向这个变量的指针或者引用，这个指针或者引用所指向的内存就不再有效，使用它就会发生错误。

### 问题 14 :   能够返回一个对象成员的指针或者引用? 为什么？

可以在 C++ 中返回指向对象成员的指针或引用，当您希望允许函数的调用者直接修改成员时，这会很有用。

返回指向对象成员的引用或指针在某些情况下很有用，但如果使用过度，也会使您的代码更难理解和维护。 使用 getter 和 setter 函数访问对象成员通常是一个好主意，而不是直接返回成员的引用或指针。

### 问题 15 :    使用 inline 的函数的优点与缺点是什么? 适用的场景的是什么？

内联函数是 C++ 中的一项功能，它允许编译器直接在调用函数的位置插入函数代码，而不是在该位置生成调用函数的代码。 这可能会提高程序的性能，因为它消除了进行函数调用的开销。

使用内联函数的一个优点是它们可以减少程序执行所需的时间，因为它们消除了进行函数调用的开销。 这对于经常调用的小函数尤其有用。

但是，使用内联函数也有一些缺点。 一是它们可以增加生成代码的大小，因为函数的代码被插入到调用函数的每个点。 这会导致更大的可执行文件和增加的内存使用量。 内联函数也更难调试，因为调试器无法像处理普通函数那样单步调试内联函数的代码。

通常，内联函数对于频繁调用的小函数最有用，因为在这些情况下性能优势更为显着。 但是，重要的是要考虑使用内联函数所涉及的权衡并明智地使用它们。

### 问题 16  ： 能够继承的两个类在 public 继承下，应具有什么关系？请举例说明?

在 public 继承中，派生类继承基类的 public 成员和 protected 成员。 派生类成为基类的子类，基类成为派生类的超类。 派生类可以像访问自己的成员一样访问基类的 public 和 protected 成员，但是基类不能访问派生类的成员。

下面是两个可以通过公共继承关联的类的示例：

```
class Animal {
  public:
    Animal(string name);
    void makeNoise();
  protected:
    string name;
};

class Dog : public Animal {
  public:
    Dog(string name);
    void fetch();
};
```

在此示例中，Animal 类是基类，Dog 类是派生类。 Dog 类公开继承自 Animal 类，这意味着它可以访问 Animal 类的 name 成员，并且可以像 Dog 类的成员一样使用 makeNoise 方法。 另一方面，Animal 类无法访问 Dog 类的 fetch 方法。

### 问题 17  :    有没有能够替换虚函数的设计？如果有？请说明

有，虚函数可以替换为其他设计模式，例如策略模式或命令模式。

策略模式涉及为每个行为创建一个单独的类，并使用组合来允许对象将该行为的执行委托给策略对象。 这允许您通过换出它正在使用的策略对象来在运行时更改对象的行为。

命令模式涉及创建表示动作或操作的对象。 这些命令对象可以在以后传递和调用，允许您将调用操作的对象与执行操作的对象分离。 例如，这对于实现撤消/重做功能很有用。

这两种模式都允许您获得与虚函数类似的结果，但它们以不同的方式实现。 使用哪一个最好取决于您的应用程序的具体要求。